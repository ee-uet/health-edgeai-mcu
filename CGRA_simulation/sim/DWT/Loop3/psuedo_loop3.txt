Psuedo format for the CGRA assembly code of the following C loop:   

    for (i = 0; i < N2; i++) {
        k = 2 * i;
        A1_rec[k]     = filter[0] * A2[i];
        A1_rec[k + 1] = filter[1] * A2[i];
    }

This gives us a good way to visualize CGRA execution.
It will also be used to select the load addresses for behavioral simulation.

Assume that addresses provided to the columns are

z1	| z2  | z3	| z4

--------------------


0 {
	a2 (r0) = z1[0];
	b2 (r0) = z2[0];
	b4 (r0) = z2[1];
	c4 (r0) = z3[0];
	d2 (r0) = z4[0];
	d3 (r0) = z4[1];
	d4 (r0) = 0;
}

1 {
	d1 = 0;
}

2 {
	a1 = 0;
	d1 = 0;
	d4 = 1;
}

3 {
	a1 = 1;
	a2 = z1[0];
	c1 = 0;
	d1 = 1;
	d2 = *z4[0];
}

4 {
	a1 = 4;
	a2 = 4;
	b2 = *z1[0];
	b4 = *z2[1];
	c4 = z3[0];
	d1 = 2;
	d4 = 2;
}

5 {
	a1 = 3;
	a2 = z1[0]+4;
	b1 = *z1[0] * *z2[1];
	b2 = z2[0]+4;
	c1 = 8;
	c2 = *z1[0] * *z4[0];
	d1 = 2;
	d2 = *z4[0];
}

6 {
	a1 = 8;
	a2 = 12;
	store *z1[0] * *z2[1] at address z2[0]+4
	b2 = *(z1[0]+4);
	b4 = *z2[1];
	store *z1[0] * *z4[0] at address z3[0]
	c4 = z3[0]+8;
	d1 = 4;
	if (d4 != z4[1]) jump to instruction 5
	d4 = 3;
}

5 (2) {
	a1 = 5;
	a2 = z1[0]+8;
	b1 = *(z1[0]+4) * *z2[1];
	b2 = z2[0]+12;
	c1 = 16;
	c2 = *(z1[0]+4) * *z4[0];
	d1 = 3;
	d2 = *z4[0];
}

6 (2) {
	a1 = 12;
	a2 = 20;
	store *(z1[0]+4) * *z2[1] at address z2[0]+12
	b2 = *(z1[0]+8);
	b4 = *z2[1];
	store *(z1[0]+4) * *z4[0] at address z3[0]+8
	c4 = z3[0]+16;
	d1 = 6;
	if (d4 != z4[1]) jump to instruction 5
	d4 = 4;
}


From this we can conclude that
N1 = z4[1]
A2 = z1[0]
h0 = *z4[0]
h1 = *z2[1]
A1_rec = z2[0] = z3[0];

Now we can select addresses accordingly
